======
filter
======

This framework is designed to filter and split Excel files using a
series of modular readers, filters, and writers. These components are
described below, followed by documentation for the currently available
readers, filters and writers. Right an the bottom is an example usage
of the filter framework.

Readers
=======

Readers are components that get data from a source and parse it into a
series of xlrd.Book objects before making calls to the appropriate
methods on the first filter in the chain. 

Because it is usually only the source of the data to be processed that
changes, a handy base class is provided for readers.

Here's an example reader that uses this base class to process the file
it is initialised with:

>>> import os
>>> from xlrd import open_workbook
>>> from xlutils.filter import BaseReader
>>> class MyReader(BaseReader):
...
...    def __init__(self,filename):
...       self.filename = filename
...
...    def get_filepaths(self):
...       return (os.path.join(test_files,self.filename),)

If you need to create a more unorthodox reader, such as one that reads
its data from a network socket or that needs to pass special
parameters to xlrd.open_workbook then read the implementation of
xlutils.filter.BaseReader

Filters
=======

Filters are the important bits of this framework. They are build up in
chains to achieve the results required for a particular task. A filter
must define certain methods, the full set of these is shown in the
example below. The implementation of these methods can do whatever the
filter requires, but generally they end up calling the appropriate
methods on the next filter. 

Here's an example filter that does nothing but print messages when its
methods are called and then call the next filter in the chain:

>>> class MyFilter:
...
...    def __init__(self,name):
...        self.name = name
... 
...    def workbook(self,rdbook,wtbook_name):
...        print self.name,'workbook',rdbook,wtbook_name
...        self.next.workbook(rdbook,wtbook_name)
...    
...    def sheet(self,rdsheet,wtsheet_name):
...        print self.name,'sheet',rdsheet,wtsheet_name
...        self.next.sheet(rdsheet,wtsheet_name)
...        
...    def row(self,rdrowx,wtrowx):
...        print self.name,'row',rdrowx,wtrowx
...        self.next.row(rdrowx,wtrowx)
...
...    def cell(self,rdrowx,rdcolx,wtrowx,wtcolx):
...        print self.name,'cell',rdrowx,rdcolx,wtrowx,wtcolx
...        self.next.cell(rdrowx,rdcolx,wtrowx,wtcolx)
...
...    def finish(self):
...        print self.name, 'finish'
...        self.next.finish()

For full details of when each of these methods are called, see the
docstrings of the xlutils.filter.BaseFilter

Writers
=======

Writers are components that get handle calls from the appropriate
methods on the last filter in the chain. It is the writer that
actually does the work of copying all the information from the
appropriate sources and writing them to the output files.

Because there is a lot of work involved in this and it is only usually
the method of writing the binary data to its destination that differs,
a handy base class is provided for writers.

Here's an example writer that just writes the data to a temporary
directory:

>>> from xlutils.filter import BaseWriter
>>> class MyWriter(BaseWriter):
...
...    def get_stream(self,filename):
...       return open(os.path.join(temp_dir,filename),'wb')

Available Readers
=================

  GlobReader
  ----------------

  If you're processing files that are on disk, then this is probably
  the reader for you. It returns all files matching the path
  specification it's created with. Here's an example:

  >>> from xlutils.filter import GlobReader
  >>> r = GlobReader(os.path.join(test_files,'*.xls'))
  >>> [p[len(test_files)+1:] for p in r.get_filepaths()]
  ['test.xls', 'testall.xls']

  All the other functionality is provided by BaseReader:

  >>> isinstance(r,BaseReader)
  True

Available Writers
=================

  DirectoryWriter
  ---------------

  If you're processing files that are on disk, then this is probably
  the writer for you. It stores files in the directory passed to it
  during creation. Here's an example:

  >>> from xlutils.filter import DirectoryWriter
  >>> w = DirectoryWriter(temp_dir)
  >>> os.listdir(temp_dir)
  []
  >>> f = w.get_stream('test.xls')
  >>> f.write('some \r\n data')
  >>> f.close()
  >>> os.listdir(temp_dir)
  ['test.xls']
  >>> open(os.path.join(temp_dir,'test.xls'),'rb').read()
  'some \r\n data'
  >>> os.remove(os.path.join(temp_dir,'test.xls'))

  All the other functionality is provided by BaseWriter:

  >>> isinstance(w,BaseWriter)
  True

  TestCallable
  ------------

  While not specifically a writer, this component can be used as one
  and is very helpful when unit testing since it collects information
  about all calls made to attributes of it. This is probably best
  demonstrated with an example:

  >>> from xlutils.tests.test_filter import TestCallable
  >>> c = TestCallable()
  >>> c.method1()
  >>> c.method2(1,2,3)
  >>> c.called
  [('method1', ()), ('method2', (1, 2, 3))]

Available Filters
=================

  BaseFilter
  ----------

  This is a "do nothing" filter that makes a great base class for your
  own filters. All the required methods are implemented such that they
  just call the same method on the next filter in the chain.

Example Usage
=============

Here's a simple example that filters out odd numbered rows from an
original workbook's sheets. It makes use of the components from the
examples above but needs one more filter:

>>> from xlutils.filter import BaseFilter
>>> class EvenFilter(BaseFilter):
...
...     def row(self,rdrowx,wtrowx):
...         if not rdrowx%2:
...             self.next.row(rdrowx,wtrowx)
...     
...     def cell(self,rdrowx,rdcolx,wtrowx,wtcolx):
...         if not rdrowx%2:
...             self.next.cell(rdrowx,rdcolx,wtrowx,wtcolx)

Now we can put it all together with a call to the process function:

>>> from xlutils.filter import process
>>> process(
...     MyReader('test.xls'),
...     MyFilter('before'),
...     EvenFilter(),
...     MyFilter('after'),
...     MyWriter()
...     )
before workbook <xlrd.Book object at ...> test.xls
after workbook <xlrd.Book object at ...> test.xls
before sheet <xlrd.sheet.Sheet object at ...> Sheet1
after sheet <xlrd.sheet.Sheet object at ...> Sheet1
before row 0 0
after row 0 0
before cell 0 0 0 0
after cell 0 0 0 0
before cell 0 1 0 1
after cell 0 1 0 1
before row 1 1
before cell 1 0 1 0
before cell 1 1 1 1
before sheet <xlrd.sheet.Sheet object at ...> Sheet2
after sheet <xlrd.sheet.Sheet object at ...> Sheet2
before row 0 0
after row 0 0
before cell 0 0 0 0
after cell 0 0 0 0
before cell 0 1 0 1
after cell 0 1 0 1
before row 1 1
before cell 1 0 1 0
before cell 1 1 1 1
before finish
after finish

As you can see if you've read this far, there's quite a lot of output,
but it's certainly informative! However, just to be on the safe side,
we can see that the output file was actually written:

>>> os.listdir(temp_dir)
['test.xls']
